"""
Greeks Monitoring Sentinel & Risk Manager

Provides portfolio-level Greeks monitoring and risk management:

Mathematical Framework (all formulas explained in pseudocode):
─────────────────────────────────────────────────────────────
Position Delta = Σ(leg_delta × contracts × 100 × direction)
    where direction = +1 for long, -1 for short

Position Gamma = Σ(leg_gamma × contracts × 100)
    Gamma risk = gamma × (underlying_price)² × 0.01
    This is the dollar P&L from a 1% move in the underlying

Portfolio Theta = Σ(leg_theta × contracts × 100 × direction)
    Daily income/decay from time passage

Portfolio Vega = Σ(leg_vega × contracts × 100 × direction)
    Sensitivity to 1% change in implied volatility

Delta-Adjusted Notional = |position_delta| × underlying_price × 100
    Capital exposure after delta adjustment

Key risk rules:
- Delta breach: |net delta| > threshold → hedge or close
- Gamma spike: dollar gamma > threshold → reduce position
- Theta/premium ratio: theta should justify the risk taken
- Concentration: no single position > max_pct of portfolio
"""

import math
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Tuple

from options.pricing import (
    call_price, put_price, delta, gamma, theta, vega,
    all_greeks, GreeksResult,
)


@dataclass
class GreeksAlert:
    """Alert generated by the Greeks sentinel."""
    level: str          # "INFO", "WARNING", "CRITICAL"
    metric: str         # Which Greek triggered it
    current_value: float
    threshold: float
    message: str
    action: str         # Recommended action

    def __repr__(self):
        return f"[{self.level}] {self.metric}: {self.message}"


@dataclass
class PositionGreeks:
    """Aggregate Greeks for a single multi-leg position."""
    net_delta: float = 0.0
    net_gamma: float = 0.0
    net_theta: float = 0.0    # Daily
    net_vega: float = 0.0     # Per 1% IV move
    gamma_dollars: float = 0.0  # Dollar gamma risk (1% underlying move)
    delta_dollars: float = 0.0  # Dollar delta exposure


@dataclass
class PortfolioRisk:
    """Portfolio-level risk snapshot."""
    total_delta: float = 0.0
    total_gamma: float = 0.0
    total_theta: float = 0.0
    total_vega: float = 0.0
    gamma_dollars: float = 0.0
    delta_notional: float = 0.0
    num_positions: int = 0
    margin_used: float = 0.0
    margin_available: float = 0.0
    alerts: List[GreeksAlert] = field(default_factory=list)

    def __repr__(self):
        return (f"PortfolioRisk(Δ={self.total_delta:+.2f}, "
                f"Γ={self.total_gamma:.4f}, "
                f"Θ={self.total_theta:+.2f}/day, "
                f"V={self.total_vega:+.2f}, "
                f"Δ$={self.delta_notional:+,.0f}, "
                f"Γ$={self.gamma_dollars:+,.0f}, "
                f"alerts={len(self.alerts)})")


class GreeksSentinel:
    """Monitors position Greeks and generates risk alerts.

    Configuration thresholds:
    - delta_threshold: Max absolute net delta (default 0.50)
    - gamma_dollar_threshold: Max dollar gamma per 1% move (default $500)
    - theta_ratio_min: Minimum theta/premium ratio (default 0.01)
    - max_vega_exposure: Max vega dollars per 1% vol (default $1000)
    - max_position_pct: Max single position as % of portfolio (default 0.20)
    """

    def __init__(self,
                 delta_threshold: float = 0.50,
                 gamma_dollar_threshold: float = 500.0,
                 theta_ratio_min: float = 0.01,
                 max_vega_exposure: float = 1000.0,
                 max_position_pct: float = 0.20,
                 portfolio_capital: float = 100_000.0):
        self.delta_threshold = delta_threshold
        self.gamma_dollar_threshold = gamma_dollar_threshold
        self.theta_ratio_min = theta_ratio_min
        self.max_vega_exposure = max_vega_exposure
        self.max_position_pct = max_position_pct
        self.portfolio_capital = portfolio_capital

    def calculate_position_greeks(self, legs, underlying_price: float,
                                  remaining_dte: int, iv: float,
                                  risk_free_rate: float = 0.04) -> PositionGreeks:
        """Calculate aggregate Greeks for a multi-leg position.

        Pseudocode:
            net_delta = 0
            for each leg in position:
                leg_delta = BS_delta(S, K, T, r, σ, type)
                direction = +1 if long else -1
                net_delta += leg_delta × contracts × 100 × direction

        Args:
            legs: List of OptionTrade legs
            underlying_price: Current underlying price
            remaining_dte: Days to expiration remaining
            iv: Current implied volatility
            risk_free_rate: Risk-free rate

        Returns:
            PositionGreeks with aggregate values
        """
        T = max(remaining_dte / 365.0, 1 / 365.0)
        S = underlying_price
        r = risk_free_rate

        pos = PositionGreeks()

        for leg in legs:
            direction = 1.0 if leg.action == "buy" else -1.0
            multiplier = leg.contracts * 100 * direction

            K = leg.strike
            opt_type = leg.option_type

            leg_delta = delta(S, K, T, r, iv, opt_type)
            leg_gamma = gamma(S, K, T, r, iv)
            leg_theta = theta(S, K, T, r, iv, opt_type)
            leg_vega = vega(S, K, T, r, iv)

            pos.net_delta += leg_delta * multiplier
            pos.net_gamma += leg_gamma * multiplier
            pos.net_theta += leg_theta * multiplier
            pos.net_vega += leg_vega * multiplier

        # Dollar exposures
        # Gamma dollars: P&L from 1% move = 0.5 × gamma × (S × 0.01)² × multiplier
        # Simplified: gamma × S² × 0.0001 × 0.5
        pos.gamma_dollars = abs(pos.net_gamma) * S * S * 0.0001 * 0.5
        pos.delta_dollars = pos.net_delta * S

        return pos

    def check_position(self, legs, underlying_price: float,
                       remaining_dte: int, iv: float,
                       net_credit: float = 0.0,
                       risk_free_rate: float = 0.04) -> Tuple[PositionGreeks, List[GreeksAlert]]:
        """Analyze a position and generate alerts.

        Returns:
            Tuple of (PositionGreeks, list of alerts)
        """
        greeks = self.calculate_position_greeks(
            legs, underlying_price, remaining_dte, iv, risk_free_rate
        )
        alerts = []

        # Check Delta
        if abs(greeks.net_delta) > self.delta_threshold:
            level = "CRITICAL" if abs(greeks.net_delta) > self.delta_threshold * 1.5 else "WARNING"
            alerts.append(GreeksAlert(
                level=level,
                metric="DELTA",
                current_value=greeks.net_delta,
                threshold=self.delta_threshold,
                message=(f"Net delta {greeks.net_delta:+.3f} exceeds "
                         f"threshold ±{self.delta_threshold:.2f}"),
                action="Consider delta hedge: buy/sell underlying shares"
            ))

        # Check Gamma dollars
        if greeks.gamma_dollars > self.gamma_dollar_threshold:
            level = "CRITICAL" if greeks.gamma_dollars > self.gamma_dollar_threshold * 2 else "WARNING"
            alerts.append(GreeksAlert(
                level=level,
                metric="GAMMA",
                current_value=greeks.gamma_dollars,
                threshold=self.gamma_dollar_threshold,
                message=(f"Dollar gamma ${greeks.gamma_dollars:,.0f} exceeds "
                         f"${self.gamma_dollar_threshold:,.0f} per 1% move"),
                action="Reduce position size or add gamma-reducing hedge"
            ))

        # Check Vega exposure
        vega_dollars = abs(greeks.net_vega)
        if vega_dollars > self.max_vega_exposure:
            alerts.append(GreeksAlert(
                level="WARNING",
                metric="VEGA",
                current_value=vega_dollars,
                threshold=self.max_vega_exposure,
                message=(f"Vega exposure ${vega_dollars:,.0f} exceeds "
                         f"${self.max_vega_exposure:,.0f} per 1% vol"),
                action="Hedge vega or reduce position notional"
            ))

        # Check Theta efficiency (for premium-selling strategies)
        if net_credit > 0 and greeks.net_theta < 0:
            # For credit strategies, theta should be positive (working for us)
            # net_theta is typically negative for long options
            pass  # Theta naturally works in our favor for credit positions

        # Theta starvation check: if theta is tiny relative to risk
        if abs(greeks.net_theta) < self.theta_ratio_min and remaining_dte > 7:
            alerts.append(GreeksAlert(
                level="INFO",
                metric="THETA",
                current_value=greeks.net_theta,
                threshold=self.theta_ratio_min,
                message=f"Theta decay ${greeks.net_theta:+.2f}/day is minimal",
                action="Position has limited time decay benefit"
            ))

        return greeks, alerts

    def check_portfolio(self, positions, underlying_price: float,
                        iv: float, risk_free_rate: float = 0.04) -> PortfolioRisk:
        """Analyze the entire portfolio of positions.

        Args:
            positions: List of (remaining_dte, legs, net_credit) tuples
            underlying_price: Current underlying price
            iv: Current implied volatility

        Returns:
            PortfolioRisk summary with all alerts
        """
        risk = PortfolioRisk()
        all_alerts = []

        for remaining_dte, legs, net_credit in positions:
            greeks, alerts = self.check_position(
                legs, underlying_price, remaining_dte, iv,
                net_credit, risk_free_rate
            )
            risk.total_delta += greeks.net_delta
            risk.total_gamma += greeks.net_gamma
            risk.total_theta += greeks.net_theta
            risk.total_vega += greeks.net_vega
            risk.gamma_dollars += greeks.gamma_dollars
            risk.num_positions += 1
            all_alerts.extend(alerts)

        risk.delta_notional = risk.total_delta * underlying_price * 100

        # Portfolio-level checks
        if abs(risk.total_delta) > self.delta_threshold * risk.num_positions:
            all_alerts.append(GreeksAlert(
                level="CRITICAL",
                metric="PORTFOLIO_DELTA",
                current_value=risk.total_delta,
                threshold=self.delta_threshold * risk.num_positions,
                message=(f"Portfolio delta {risk.total_delta:+.2f} is directionally "
                         f"biased (notional ${risk.delta_notional:+,.0f})"),
                action="Hedge portfolio delta to neutral"
            ))

        # Concentration check
        if risk.num_positions > 0:
            per_position_risk = self.portfolio_capital / risk.num_positions
            if per_position_risk > self.portfolio_capital * self.max_position_pct:
                all_alerts.append(GreeksAlert(
                    level="WARNING",
                    metric="CONCENTRATION",
                    current_value=risk.num_positions,
                    threshold=1 / self.max_position_pct,
                    message=f"Only {risk.num_positions} positions - high concentration risk",
                    action="Diversify across more positions or reduce size"
                ))

        risk.alerts = all_alerts
        return risk

    def suggest_delta_hedge(self, net_delta: float, underlying_price: float) -> str:
        """Suggest a delta hedge.

        Pseudocode:
            shares_to_trade = -round(net_delta × 100)
            If net_delta > 0: sell shares (short hedge)
            If net_delta < 0: buy shares (long hedge)
        """
        shares = -round(net_delta * 100)
        if shares > 0:
            return (f"BUY {shares} shares of underlying @ ${underlying_price:.2f} "
                    f"(cost: ${shares * underlying_price:,.0f}) to neutralize delta")
        elif shares < 0:
            return (f"SELL {abs(shares)} shares of underlying @ ${underlying_price:.2f} "
                    f"(proceeds: ${abs(shares) * underlying_price:,.0f}) to neutralize delta")
        else:
            return "Position is approximately delta-neutral"


def format_risk_report(risk: PortfolioRisk) -> str:
    """Generate a formatted risk report."""
    lines = []
    lines.append("─" * 70)
    lines.append("  GREEKS RISK MONITOR")
    lines.append("─" * 70)
    lines.append(f"  Positions:       {risk.num_positions}")
    lines.append(f"  Net Delta:       {risk.total_delta:>+10.3f}")
    lines.append(f"  Net Gamma:       {risk.total_gamma:>+10.4f}")
    lines.append(f"  Net Theta:       ${risk.total_theta:>+9.2f}/day")
    lines.append(f"  Net Vega:        ${risk.total_vega:>+9.2f}/1%vol")
    lines.append(f"  Delta Notional:  ${risk.delta_notional:>+12,.0f}")
    lines.append(f"  Gamma Dollars:   ${risk.gamma_dollars:>+12,.0f} per 1% move")
    lines.append("")

    if risk.alerts:
        lines.append("  ALERTS:")
        for alert in risk.alerts:
            icon = {"INFO": "  ", "WARNING": "! ", "CRITICAL": "!!"}
            lines.append(f"  {icon.get(alert.level, '  ')}[{alert.level}] "
                         f"{alert.message}")
            lines.append(f"      → {alert.action}")
    else:
        lines.append("  No alerts - all Greeks within thresholds.")

    lines.append("")
    return "\n".join(lines)
